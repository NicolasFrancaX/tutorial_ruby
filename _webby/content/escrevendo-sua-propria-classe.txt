---
title:      Escrevendo nossa própria classe em Ruby
created_at: 2010-01-16 22:50:12.243193 -03:00
filter:
  - erb
  - textile
---
p(title). <%= h(@page.title) %>

O paradigma procedural foi utilizado até agora para escrevermos nossos programas (note que este paradigma continua sendo utilizado em linguagens como C). Programar proceduralmente quer dizer que focamos nos passos requeridos para completar uma tarefa (de programação) sem dar muita atenção em como os dados são manipulados.

No paradigma de Orientação a Objetos, objetos são nossos agentes, "procuradores", no escopo do nosso programa. Pedimos informações para os objetos. Atribuimos para eles tarefas. Dizemos para eles executarem cálculos e, em seguida, retornar o valor calculado. Juntamos uns aos outros para que trabalhem conjuntamente.

Quando projetamos uma classe, pensamos sobre os objetos que serão criados com base naquele tipo de classe. Pensamos sobre as coisas que o objeto sabe e faz.

Coisas que o objeto sabe sobre ele mesmo são chamadas variáveis de instancia. Elas representam o estado do objeto (os dados: por exemplo, a quantidade e o código do produto), e podem ter valores únicos para cada objeto daquele tipo.

Coisas que um objeto podem fazer são chamados métodos.

<div class='box'>
Um objeto é uma entidade que serve como um conteiner de dados e que controla o acesso a eles. Associando a um objeto um conjunto de atribudos, que, essencialmente, não são mais do que variáveis que pertencem ao objeto. Também podem ser associados a um objeto um conjuto de funções que disponibilizam um meio (interface) de operarmos sobre os dados do objeto, chamados métodos. - Hal Fulton (N.T.: Tradução Livre do original)
</div>

Um objeto é uma combinação de estados (dados) e métodos que modificam estes estados (funções).

Dessa forma uma classe é usada para contruir um objeto. Uma classe é um molde para um objeto. Por exemplo, podemos usar uma classe Botão para fazer dezenas de botões diferentes, cada botão tendo sua própria cor, tamanho, forma, entre outras. Um objeto é uma instância de uma classe.

<div class='box'>
b. Leia cuidadosamente

Classes em Ruby são objetos de primeira classes - todas são intâncias da classe Class. Quando uma nova classe é definida (normalmente usando class Nome ... end), um objeto do tipo Class é criado e é associado a uma contante (Nome, neste caso). Quando Nome.new é chamado para criar um novo objeto, o método de classe new da classe Class é executado primeiro para alocar memória para o objeto (atravéz do método allocate) e, em seguida, o método initialize do novo objeto é executado. As fases de construção e inicialização de um objeto são separadas e ambas podem ser sobrescritas. A inicialização é feita pelo método de instância initialize, enquanto a contrução é feita pelo método de classe new. O método initialize não é um contrutor.
</div>

Vamos escrever nossa primera classe - p029dog.rb

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
# p029dog.rb
# define class Dog
class Dog
  def initialize(breed, name)
    # Instance variables
    @breed = breed
    @name = name
  end

  def bark
    puts 'Ruff! Ruff!'
  end

  def display
    puts "I am of #{@breed} breed and my name is #{@name}"
  end
end

# make an object
# Objects are created on the heap
d = Dog.new('Labrador', 'Benzy')

=begin
  Every object is "born" with certain innate abilities.
  To see a list of innate methods, you can call the methods
  method (and throw in a sort operation, to make it
  easier to browse visually). Remove the comment and execute.
=end
# puts d.methods.sort

# Amongst these many methods, the methods object_id and respond_to? are important.
# Every object in Ruby has a unique id number associated with it
puts "The id of obj is #{d.object_id}."

# To know whether the object knows how to handle the message you want
# to send it, by using the respond_to? method.
if d.respond_to?("talk")
  d.talk
else
  puts "Sorry, the object doesn't understand the 'talk' message."
end

d.bark
d.display

# making d and d1 point to the same object
d1 = d
d1.display

# making d a nil reference, meaning it does not refer to anything
d = nil
d.display

# If I now say
d1 = nil
# then the Dog object is abandoned and eligible for Garbage Collection (GC)
<% end -%>

A saída é esta:

<% coderay(:language => 'bash', :line_number => 'inline') do -%>
>ruby p029dog.rb
The id of obj is 22982920.
Sorry, the object doesn't understand the 'talk' message.
Ruff! Ruff!
I am of Labrador breed and my name is Benzy
I am of Labrador breed and my name is Benzy
>Exit code: 0
<% end -%>

O método new é usado para criar um objeto da classe Dog. Objetos são criados no heap. A variável d é conhechida como uma variável de referência. Isso quer dizer que ela não contém o objeto, mas somente contém alguma coisa como um ponteiro ou um endereço (de memória) para o objeto. Utilizamos o operador ponto (.) em uma variável de referência para "dizer" ao objeto: "use a coisa antes do ponto (objeto) para fazer a coisa depois do ponto (executar o método)." Por exemplo:

b. d.bark

<div class='box'>
Em Rails: Se estivermos escrevendo uma aplicação em Rais em que uma das entidades do modelo seja Cliente, então quando escrevermos o código que fazem as coisas acontecerem - um cliente acessa a área restrida de um site, atualiza seu número de telefone, adiciona um ítem em seu carrinho de compras - em todas essas situações estamos enviando mensagens para os objetos cliente.
</div>

Mesmo um objeto criado recentemente não é algo vazio. Tão breve quanto um objeto passa a existir, ele já responde a certo número de mensagens. Todo objeto "nasce" com certas habilidades inatas. Para ver uma lista desses métodos inatos, podemos chamar o método methods (e ainda solicitar que o resultado seja ordenado - chamando o método sort, - para facilitar a visualização):

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
puts d.methods.sort
<% end -%>

O resultato é uma lista com todas as mensagens (métodos) que este novo e recém-criado método possui. Entre todos estes muitos métodos, os métodos object_id e respond_to? são importantes.

Todo objeto em Ruby possui um identificador numérico único associado a ele. Podemos ver este identificado pedindo para o objeto mostrar seu identificador (via método object_id):

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
puts "The id of obj is #{d.object_id}."
<% end -%>

Podemos determinar antecipadamente (antes de perguntarmos alguma coisa para o objeto) se o objeto sabe como responder a mensagem que pretendemos enviar. Fazemos isso utilizando o método respond_to?. Esse método existe em todos os objetos; podemos questionar qualquer objeto para verificar se ele responde alguma mensagem. O método respond_to? normalmente aparece em conjunto com um teste lógico condicional (if).

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
if d.respond_to?("talk")
  d.talk
else
  puts "Sorry, the object doesn't understand the 'talk' message."
end
<% end -%>

As seguintes instruções:
<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
d1 = d
d1.display
<% end -%>
fazem com que d e d1 apontem para o mesmo objeto.

Podemos perguntar para qualquer objeto de qual classe ele é membro utilizando o método Objeto.class. No programa acima, se escrevermos as seguintes instruções:

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
d = Dog.new('Alsatian', 'Lassie')
puts d.class.to_s
<% end -%>

O resultado será:

<% coderay(:language => 'bash', :line_numbers => 'inline') do -%>
>ruby p029dog.rb
Dog
>Exit code: 0
<% end -%>

O método instance_of? retorna verdadeiro (true) se um objeto é instância de dada classe, como no exemplo abaixo?

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
num = 10
puts(num.instance_of? Fixnum) # output true
<% end -%>


h2. Construtores Literais

Isso significa que podemos utilizar uma notação especial, ao invés de chamar new, para criar um novo objeto de determinada classe. As classes com construtores literais são demonstradas abaixo. Quando usamos algum desses construtores literais, fazemos que um novo objeto passe a existir.

b. Exemplos:

String - 'hello' or "hello"
Symbol - :symbol or :"hello wrold"
Array - [x, y, z]
Hash - {"India" => "IN"}
Range - 3..7 or 3...7

h2. Coleta de Lixo (Garbage Collection)

A instrução abaixo:

d =nil

faz com que d receba uma referencia para nil, isto significa que d não aponta para coisa alguma. Agora, se fizermos:

d1 = nil

então o objeto Dog é abandonado e eleito para a Coleta de Lixo (Garbage Collection - GC). The Ruby object heap allocates a minimum of 8 megabytes. Ruby's GC is called mark-and-sweep. The "mark" stage checks objects to see if they are still in use. If an object is in a variable that can still be used in the current scope, the object (and any object inside that object) is marked for keeping. If the variable is long gone, off in another method, the object isn't marked. The "sweep" stage then frees objects which haven't been marked.

Ruby uses a conservative mark-and-sweep GC mechanism. There is no guarantee that an object will undergo garbage collection before the program terminates.

If you stuff something in an array and you happen to keep that array around, it's all marked. If you stuff something in a constant or global variable, it's forever marked.
Class Methods

The idea of a class method is that you send a message to the object that is the class rather than to one of the class's instances. Class methods serve a purpose. Some operations pertaining to a class can't be performed by individual instances of that class. new is an excellent example. We call Dog.new because, until we've created an individual dog instance, we can't send it any messages! Besides, the job of spawning a new object logically belongs to the class. It doesn't make sense for instances of Dog to spawn each other. It does make sense, however, for the instance-creation process to be centralized as an activity of the class Dog. It's vital to understand that by Dog.new, we have a method that we can access through the class object Dog but not through its instances. Individual dog objects (instances of the class Dog) do not have this method. A class object (like Dog) has its own methods, its own state, its own identity. It doesn't share these things with instances of itself.

Here's an example:

Dog#bark - the instance method bark in the class Dog

Dog.color - the class method color, in the class Dog

Dog::color - another way to refer to the class method color

In writing about Ruby, the pound notation (#) is sometimes used to indicate an instance method - for example, we say File.chmod to denote the class method chmod of class File, and File#chmod to denote the instance method that has the same name. This notation is not part of Ruby syntax.

You will learn how to write class methods, later on here.
