---
title:      Escrevendo nossa própria classe em Ruby
created_at: 2010-01-16 22:50:12.243193 -03:00
filter:
  - erb
  - textile
---
p(title). <%=h(@page.title) %>

O paradigma procedural foi utilizado até agora para escrevermos nossos programas (note que este paradigma continua sendo utilizado em linguagens como C). Programar proceduralmente quer dizer que focamos nos passos requeridos para completar uma tarefa (de programação) sem dar muita atenção em como os dados são manipulados.

No paradigma de Orientação a Objetos, objetos são nossos agentes, "procuradores", no escopo do nosso programa. Pedimos informações para os objetos. Atribuimos para eles tarefas. Dizemos para eles executarem cálculos e, em seguida, retornar o valor calculado. Juntamos uns aos outros para que trabalhem conjuntamente.

Quando projetamos uma classe, pensamos sobre os objetos que serão criados com base naquele tipo de classe. Pensamos sobre as coisas que o objeto sabe e faz.

Coisas que o objeto sabe sobre ele mesmo são chamadas variáveis de instancia. Elas representam o estado do objeto (os dados: por exemplo, a quantidade e o código do produto), e podem ter valores únicos para cada objeto daquele tipo.

Coisas que um objeto podem fazer são chamados métodos.

<div class='box'>
Um objeto é uma entidade que serve como um conteiner de dados e que controla o acesso a eles. Associando a um objeto um conjunto de atribudos, que, essencialmente, não são mais do que variáveis que pertencem ao objeto. Também podem ser associados a um objeto um conjuto de funções que disponibilizam um meio (interface) de operarmos sobre os dados do objeto, chamados métodos. - Hal Fulton (N.T.: Tradução Livre do original)
</div>

Um objeto é uma combinação de estados (dados) e métodos que modificam estes estados (funções).

Dessa forma uma classe é usada para contruir um objeto. Uma classe é um molde para um objeto. Por exemplo, podemos usar uma classe Botão para fazer dezenas de botões diferentes, cada botão tendo sua própria cor, tamanho, forma, entre outras. Um objeto é uma instância de uma classe.

<div class='box'>
b. Leia cuidadosamente

Classes em Ruby são objetos de primeira classes - todas são intâncias da classe Class. Quando uma nova classe é definida (normalmente usando class Nome ... end), um objeto do tipo Class é criado e é associado a uma contante (Nome, neste caso). Quando Nome.new é chamado para criar um novo objeto, o método de classe new da classe Class é executado primeiro para alocar memória para o objeto (atravéz do método allocate) e, em seguida, o método initialize do novo objeto é executado. As fases de construção e inicialização de um objeto são separadas e ambas podem ser sobrescritas. A inicialização é feita pelo método de instância initialize, enquanto a contrução é feita pelo método de classe new. O método initialize não é um contrutor.
</div>

Vamos escrever nossa primera classe - p029dog.rb

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
# p029dog.rb
# define class Dog
class Dog
  def initialize(breed, name)
    # Instance variables
    @breed = breed
    @name = name
  end

  def bark
    puts 'Ruff! Ruff!'
  end

  def display
    puts "I am of #{@breed} breed and my name is #{@name}"
  end
end

# make an object
# Objects are created on the heap
d = Dog.new('Labrador', 'Benzy')

=begin
  Every object is "born" with certain innate abilities.
  To see a list of innate methods, you can call the methods
  method (and throw in a sort operation, to make it
  easier to browse visually). Remove the comment and execute.
=end
# puts d.methods.sort

# Amongst these many methods, the methods object_id and respond_to? are important.
# Every object in Ruby has a unique id number associated with it
puts "The id of obj is #{d.object_id}."

# To know whether the object knows how to handle the message you want
# to send it, by using the respond_to? method.
if d.respond_to?("talk")
  d.talk
else
  puts "Sorry, the object doesn't understand the 'talk' message."
end

d.bark
d.display

# making d and d1 point to the same object
d1 = d
d1.display

# making d a nil reference, meaning it does not refer to anything
d = nil
d.display

# If I now say
d1 = nil
# then the Dog object is abandoned and eligible for Garbage Collection (GC)
<% end -%>

A saída é esta:

<% coderay(:language => 'bash', :line_number => 'inline') do -%>
>ruby p029dog.rb
The id of obj is 22982920.
Sorry, the object doesn't understand the 'talk' message.
Ruff! Ruff!
I am of Labrador breed and my name is Benzy
I am of Labrador breed and my name is Benzy
>Exit code: 0
<% end -%>

O método new é usado para criar um objeto da classe Dog. Objetos são criados no heap. A variável d é conhechida como uma variável de referência. Isso quer dizer que ela não contém o objeto, mas somente contém alguma coisa como um ponteiro ou um endereço (de memória) para o objeto. Utilizamos o operador ponto (.) em uma variável de referência para "dizer" ao objeto: "use a coisa antes do ponto (objeto) para fazer a coisa depois do ponto (executar o método)." Por exemplo:

b. d.bark

<div class='box'>
Em Rails: Se estivermos escrevendo uma aplicação em Rais em que uma das entidades do modelo seja Cliente, então quando escrevermos o código que fazem as coisas acontecerem - um cliente acessa a área restrida de um site, atualiza seu número de telefone, adiciona um ítem em seu carrinho de compras - em todas essas situações estamos enviando mensagens para os objetos cliente.
</div>

Mesmo um objeto criado recentemente não é algo vazio. Tão breve quanto um objeto passa a existir, ele já responde a certo número de mensagens. Todo objeto "nasce" com certas habilidades inatas. Para ver uma lista desses métodos inatos, podemos chamar o método methods (e ainda solicitar que o resultado seja ordenado - chamando o método sort, - para facilitar a visualização):

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
puts d.methods.sort
<% end -%>

O resultato é uma lista com todas as mensagens (métodos) que este novo e recém-criado método possui. Entre todos estes muitos métodos, os métodos object_id e respond_to? são importantes.

Todo objeto em Ruby possui um identificador numérico único associado a ele. Podemos ver este identificado pedindo para o objeto mostrar seu identificador (via método object_id):

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
puts "The id of obj is #{d.object_id}."
<% end -%>

Podemos determinar antecipadamente (antes de perguntarmos alguma coisa para o objeto) se o objeto sabe como responder a mensagem que pretendemos enviar. Fazemos isso utilizando o método respond_to?. Esse método existe em todos os objetos; podemos questionar qualquer objeto para verificar se ele responde alguma mensagem. O método respond_to? normalmente aparece em conjunto com um teste lógico condicional (if).

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
if d.respond_to?("talk")
  d.talk
else
  puts "Sorry, the object doesn't understand the 'talk' message."
end
<% end -%>

As seguintes instruções:
<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
d1 = d
d1.display
<% end -%>
fazem com que d e d1 apontem para o mesmo objeto.

Podemos perguntar para qualquer objeto de qual classe ele é membro utilizando o método Objeto.class. No programa acima, se escrevermos as seguintes instruções:

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
d = Dog.new('Alsatian', 'Lassie')
puts d.class.to_s
<% end -%>

O resultado será:

<% coderay(:language => 'bash', :line_numbers => 'inline') do -%>
>ruby p029dog.rb
Dog
>Exit code: 0
<% end -%>

O método instance_of? retorna verdadeiro (true) se um objeto é instância de dada classe, como no exemplo abaixo?

<% coderay(:language => 'ruby', :line_numbers => 'inline') do -%>
num = 10
puts(num.instance_of? Fixnum) # output true
<% end -%>


h2. Construtores Literais

Isso significa que podemos utilizar uma notação especial, ao invés de chamar new, para criar um novo objeto de determinada classe. As classes com construtores literais são demonstradas abaixo. Quando usamos algum desses construtores literais, fazemos que um novo objeto passe a existir.

b. Exemplos:

String - 'hello' or "hello"
Symbol - :symbol or :"hello wrold"
Array - [x, y, z]
Hash - {"India" => "IN"}
Range - 3..7 or 3...7

h2. Coleta de Lixo (Garbage Collection)

A instrução abaixo:

d =nil

faz com que d receba uma referencia para nil, isto significa que d não aponta para coisa alguma. Agora, se fizermos:

d1 = nil

então o objeto Dog é abandonado e eleito para a Coleta de Lixo (Garbage Collection - GC). O Ruby aloca ao menos 8 megabytes de memória no heap. O coletor de lixo do Ruby é chamado de marque e limpe. O estágio de marcacão verifica se o objeto está em uso. Se um objeto é referenciado por uma variável que pode ser utilizado no escopo atual, o objeto (e qualquer objeto dentro dele) é marcado para ser mantido. Se a variável deixa de existir, e o objeto não possuir outras referencias, ele não é marcado. O estágio da limpeza remove da memória os objetos que não foram marcados.

O Ruby usa um mecanismo conservador de marcar e limpar. Não há garantia de que o objeto será liberado pelo coletor de lixo antes do programa terminar.

Se voce referenciar algum objeto como elemento de um vetor você faz com que todos objetos referenciados pelo vetor são marcados. Se você referenciar um objeto por uma constante ou por uma variável global, ele sempre será marcado.


h2. Métodos de Classe

A idéia dos métodos de classe é que você envie uma mensagem para o objeto que representa a classe ao invés de um objeto que é instância da classe. Métodos de classe cumprem esse papel. Algumas operacões devem ser executadas por pela classe e não por uma instância dela. O método new é um excelente exemplo disso. Nós chamamos Dog.new porque até que uma instância esteja instanciada, não poderemos enviar nenhuma mensagem para o objeto. Além de que, o trabalho de gerar um novo objeto pertence à classe. Não faz sentido um objeto da classe Dog gere outro objeto do mesmo tipo. Faz sentido, contudo, que o processo de criacão de um objeto seja centralizado como uma tarefa da classe Dog. É vital entender que por Dog.new, nós podemos acessar todo o objeto da classe Dog, mas não suas instâncias. Os objetos dog (instancias da classe Dog) não possuem esse método. Um objeto de classe (como Dog) possui seus próprios métodos, seu próprio estado, sua própria identidade e não divide essas caracteristicas com suas instâncias.

Aqui temos um exemplo:

Dog#bark - o método de instância bark na classe Dog

Dog.color - o método color da classe Dog

Dog::color - outra forma de escrever o método color da classe Dog

Nos textos sobre Ruby, a notacão do caractere # (tralha, sustenido, jogo-da-velha -- não sei como chama) é usado para indicar um método de instância, por exemplo, File.chmod indica o método de classe chmod da classe File, e File#chmod indica o método de instância que possui o mesmo nome. Esta notacão não é parte da sintaxe do Ruby.

Você irá aprender como criar seus métodos de classe nos próximos capítulos nesse tutorial.

