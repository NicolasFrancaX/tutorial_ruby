---
title:      Expressões Regulares
created_at: 2010-01-16 22:45:12.243193 -03:00
filter:
  - erb
  - textile
---
p(title). <%= h(@page.title) %>

Expressões regulares, como criptografia, é uma poderosa ferramenta para trabalhar com texto. Ruby possui esta funcionalidade incluida em seu núcleo. Ela é usada para o casamento de padrões e processamento de texto.

Muitas pessoas acham que expressões regulares são difíceis de usar, difíceis de ler, de manter e, consequentemente, contraprodutiva. Você pode apenas um pequeno número de expressões regulares em suas aplicacões em Ruby e Rails. Não é pré-requisito, para programar em Rails, tornar-se um especialista em Expressões Regulares. Entretanto, é recomendado o aprendizado, ao menos basicamente, de como as expressões regulares básicas funcionam.

Uma expressão regular é uma forma simples de especificar um padrão de caracteres que será casado com uma cadeia de caracteres. Em Ruby, você normalmente cria uma expressão regular escrevendo um padrão entre caracteres de barra '/' (/padrão/). Em Ruby, expressões regulares são objetos (do tipo Regexp) e podem ser manipulados como tais. // é uma expressão regular e uma instância da classe Regexp, como demonstrado abaixo:

   1. //.class    # Regexp

Você pode escrever um padrão que casa com uma cadeia de caracteres contendo o texto Prune ou o texto Ruby usando a seguinte expressão regular:

   1. /Pune|Ruby/

Caracteres de barra ('/') delimitam o padrão, que consistem em dois padrões que serão casados, separados por um caractere de pipe (|). O caractere pipe (|) significa "ou o padrão que está na direita ou no padrão que está na esquerda", neste caso Prune ou Ruby.

A forma mais simples de verificar se há um padrão que casa entre uma expressão regular e uma cadeia de caracteres é o método /match/. Você pode fazer isso em qualquer direcão: objetos Regexp e objetos String, ambos respondem ao método match. Se não houver casamento entre os padrões, o método retorna nil. Se houver um casamento de padrão, é retornado uma instância da classe MatchData. Podemos utilizar o operador =~ para casar uma cadeia de caracteres contra uma expressão regular. Caso o padrão seja encontrado, =~ retorna a posicão em que o padrão foi encontrado, caso contrário retorna nil.

   1. m1 = /Ruby/.match("The future is Ruby")
   2. puts m1.class  # it returns MatchData
   3. m2 = "The future is Ruby" =~ /Ruby/
   4. puts m2          # it returns 14

Os possíveis componentes de uma expressão regular incluem os seguintes:





= Literal characters =

Any literal character you put in a regular expression matches itself in the string.

   1. /a/  

This regular expression matches the string "a", as well as any string containing the letter "a".

Some characters have special meanings to the regexp parser. When you want to match one of these special characters as itself, you have to escape it with a backslash (\). For example, to match the character ? (question mark), you have to write this:

   1. /\?/  

The backslash means "don't treat the next character as special; treat it as itself."

The special characters include ^, $, ? , ., /, \, [, ], {, }, (, ), +, and *.



= The wildcard character . (dot) =

Sometimes you'll want to match any character at some point in your pattern. You do this with the special wildcard character . (dot). A dot matches any character with the exception of a newline. This regular expression:

   1. /.ejected/  

matches both "dejected" and "rejected". It also matches "%ejected" and "8ejected". The wildcard dot is handy, but sometimes it gives you more matches than you want. However, you can impose constraints on matches while still allowing for multiple possible strings, using character classes.



= Character classes =

A character class is an explicit list of characters, placed inside the regular expression in square brackets:

   1. /[dr]ejected/  

This means "match either d or r, followed by ejected. This new pattern matches either "dejected" or "rejected" but not "&ejected". A character class is a kind of quasi-wildcard: It allows for multiple possible characters, but only a limited number of them.

Inside a character class, you can also insert a range of characters. A common case is this, for lowercase letters:

   1. /[a-z]/  

To match a hexadecimal digit, you might use several ranges inside a character class:

   1. /[A-Fa-f0-9]/  

This matches any character a through f (upper- or lowercase) or any digit.

Sometimes you need to match any character except those on a special list. You may, for example, be looking for the first character in a string that is not a valid hexadecimal digit.

You perform this kind of negative search by negating a character class. To do so, you put a caret (^) at the beginning of the class. Here's the character class that matches any character except a valid hexadecimal digit:

   1. /[^A-Fa-f0-9]/  

Some character classes are so common that they have special abbreviations.



= Special escape sequences for common character classes =

To match any digit, you can do this:

   1. /[0-9]/  

But you can also accomplish the same thing more concisely with the special escape sequence \d:

   1. /\d/  

Two other useful escape sequences for predefined character classes are these:
\w matches any digit, alphabetical character, or underscore (_).
\s matches any whitespace character (space, tab, newline).

Each of these predefined character classes also has a negated form. You can match any character that is not a digit by doing this:

   1. /\D/  

Similarly, \W matches any character other than an alphanumeric character or underscore, and \S matches any non-whitespace character.

A successful match returns a MatchData object.

Every match operation either succeeds or fails. Let's start with the simpler case: failure. When you try to match a string to a pattern, and the string doesn't match, the result is always nil:

   1. /a/.match("b") # nil  

This nil stands in for the false or no answer when you treat the match as a true/false test.

Unlike nil, the MatchData object returned by a successful match has a Boolean value of true, which makes it handy for simple match/no-match tests. Beyond this, however, it also stores information about the match, which you can pry out of them with the appropriate methods: where the match began (at what character in the string), how much of the string it covered, what was captured in the parenthetical groups, and so forth.

To use the MatchData object, you must first save it. Consider an example where we want to pluck a phone number from a string and save the various parts of it (area code, exchange, number) in groupings. Example p064regexp.rb

   1. # p064regexp.rb  
   2. string = "My phone number is (123) 555-1234."  
   3. phone_re = /\((\d{3})\)\s+(\d{3})-(\d{4})/  
   4. m = phone_re.match(string)  
   5. unless m  
   6.   puts "There was no match..."  
   7.   exit  
   8. end  
   9. print "The whole string we started with: "  
  10. puts m.string  
  11. print "The entire part of the string that matched: "  
  12. puts m[0]  
  13. puts "The three captures: "  
  14. 3.times do |index|  
  15.   puts "Capture ##{index + 1}: #{m.captures[index]}"  
  16. end  
  17. puts "Here's another way to get at the first capture:"  
  18. print "Capture #1: "  
  19. puts m[1]  

In this code, we use the string method of MatchData (puts m.string) to get the entire string on which the match operation was performed. To get the part of the string that matched our pattern, we address the MatchData object with square brackets, with an index of 0 (puts m[0]). We also use the times method (3.times do |index|) to iterate exactly three times through a code block and print out the submatches (the parenthetical captures) in succession. Inside that code block, a method called captures fishes out the substrings that matched the parenthesized parts of the pattern. Finally, we take another look at the first capture, this time through a different technique: indexing the MatchData object directly with square brackets and positive integers, each integer corresponding to a capture.

Here's the output:

   1. >ruby p064regexp.rb  
   2. The whole string we started with: My phone number is (123) 555-1234.  
   3. The entire part of the string that matched: (123) 555-1234  
   4. The three captures:  
   5. Capture #1: 123  
   6. Capture #2: 555  
   7. Capture #3: 1234  
   8. Here's another way to get at the first capture:  
   9. Capture #1: 123  
  10. >Exit code: 0  

Read the Ruby-centric regular expression tutorial here, for a more detailed coverage on regular expressions.

The above topic has been adapted from the Ruby for Rails book.
