---
title:      Arrays em Ruby
created_at: 2010-02-17 15:06:43.133715 -02:00
filter:
  - erb
  - textile
---
p(title). <%= h(@page.title) %>

Um **Array** (arranjo) é apenas uma lista de itens em ordem (como mangas, maçãs e laranjas). Cada posição na lista atua como
uma variável: você pode ver para qual objeto uma determinada posição aponta para, e você pode fazer ela apontar para um
objeto diferente. Você pode fazer um array usando colchetes. Em Ruby, o primeiro valor em um array tem o índice 0. Os
métodos **size** e **length** retornam o número de elementos no array. O último elemento de um array está no índice **size-1**.
Valores negativos de índice são contados a partir do final do array, de modo que o último elemento de um array pode ser
acessado com um índice -1. Se você tentar ler um elemento além do final do array (com um índice >= **size**) ou antes do
início do array (com índice < -size), o Ruby simplesmente retornará nil (nulo) e não lançará uma exceção. Os arrays em
Ruby são mutáveis - arrays são redimensionados dinamicamente; você pode acrescentar elementos a eles e eles crescem o
necessário. Vamos olhar para o seguinte exemplo **p018arrays.rb**. Por favor, siga pelo programa com atenção.



<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
# p018arrays.rb  
# Arrays  
  
# array vazio  
var1 = []  
# Índice do array inicia em 0  
puts var1[0]  
  
var2 = [5]  
# um array armazenando apenas um número 
puts var2[0]  
   
# um array armazenando duas strings 
var3 = ['Olá', 'Tchau']  
puts var3[0]  
puts var3[1]  
  
sabor = 'manga'  
# um array cujos elementos apontam para três
# objetos - um float, uma string e um array  
var4 = [80.5, sabor, [true, false]]  
puts var4[2]  
  
# uma vírgula no final é ignorada
name = ['Satish', 'Talim', 'Ruby', 'Java',]  
puts name[0]  
puts name[1]  
puts name[2]  
puts name[3]  
# o próximo tem como saída nil
# nil é o jeito do Ruby dizer 'nada' 
puts name[4]  
# podemos adicionar mais elementos também
name[4] = 'Pune' 
puts name[4] 
# podemos adicionar qualquer coisa!
name[5] = 4.33 
puts name[5] 
# podemos adicionar um array a um array
name[6] = [1, 2, 3] 
puts name[6] 
 
# alguns métodos da classe array
newarr = [45, 23, 1, 90] 
puts newarr.sort 
puts newarr.length 
puts newarr.first 
puts newarr.last 
 
# o método each (iterador - extrai cada elemento em lang
# do end é um bloco de código 
# falaremos sobre blocos mais tarde
# a variável lang se refere a cada item no array a medida que ele é iterado no loop
linguas = ['Pune', 'Mumbai', 'Bangalore'] 
 
linguas.each do |lang| 
  puts 'Eu amo ' + lang + '!' 
  puts 'voce nao?'  
end  

# apaga uma entrada no meio e desloca o restante da entradas   
linguas.delete('Mumbai')

linguas.each do |lang|  
  puts 'Eu amo ' + lang + '!' 
  puts 'voce nao?'   
end  
<% end %>

O método **each** (para qualquer objeto) permite-nos fazer algo (o que quisermos) para cada (each) objeto para o qual o
array aponta. No exemplo, somos capazes de iterar sobre o array sem usar nenhum número. Aqui estão algumas coisas para
se lembrar:

* A variável lang dentro das "traves" (barras verticais) se refere a cada item no array a medida que ele é iterado no
loop. Você pode dar a esta variável o nome que quiser, mas escolha um nome especial.

* O **do** e o **end** identificam um bloco de código que será executado para cada item. Blocos são usados extensivamente em
Ruby.


Aqui está um exemplo interessante de um método que retorna um array. Exemplo **p019mtdarry.rb**.


<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
# p019mtdarry.rb  
# se você dá ao return multiplos parâmetros.  
# o método os retornará em um array 
# o método times da classe Integer itera num vezes,  
# passando para num os valores de 0 a num-1  
  
def mtdarry  
  10.times do |num|  
    quadrado = num * num  
    return n, quadrado if n > 5  
  end  
end  
  
# usando atribuição paralela para coletar o valor de retorno
num, quadrado = mtdarry  
puts num  
puts quadrado  
<% end %>

A saída é:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
>ruby p019mtdarry.rb  
6  
36  
>Exit code: 0  
<% end %>

O método **times** da classe **Integer** (inteiro) itera o bloco n vezes, passando os valors de zero a num-1. Como podemos ver, se você dá ao **return** múltiplos parâmetros, o método retorna estes em um array. Você pode usar a atribuição em paralelo para coletar esses valores de retorno.


h2.Atribuição paralela

To explain this, we'll use the terms lvalue and rvalue. An lvalue is something that can appear on its own on the left-hand side of an assignment (a variable, constant, or attribute setter method). An rvalue is something that can appear on its own on the right hand side. Ruby lets you have a comma-separated list of rvalues. Once Ruby sees more than one rvalue in an assignment, the rules of parallel assignment come into play. First, all the rvalues evaluated, left to right, and collected into an array (unless they are already an array). This array will be the eventual value returned by the overall assignment. Next, the left hand side (lhs) is inspected. If it contains a single element, the array is assigned to that element.


<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
a = 1, 2, 3, 4 # => a == [1, 2, 3, 4]  
b = [1, 2, 3, 4] # => b == [1, 2, 3, 4]  
<% end %>


If the lhs contains a comma, Ruby matches values on the rhs against successive elements on the lhs. Excess elements are discarded.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
a, b = 1, 2, 3, 4 # => a == 1, b == 2  
c, = 1, 2, 3, 4 # => c == 1  
<% end %>


h2. Variáveis de ambiente

An environment variable is a link between our program and the outside world. An environment variable is essentially a label referring to a piece of text; and can be used to store configuration information such as paths, usernames, and so on. You can access operating system environment variables using the predefined variable ENV.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
ENV.each {|k,v| puts "#{k}: #{v}"}
<% end %>

Ruby sets ENV to the environment variables. After that, iteration proceeds with each. This time, the block takes two parameters: k (key) and v (value). Blocks are a completely general mechanism and can take any number of arguments.

The values of some environment variables are read by Ruby when it first starts. These variables modify the behavior of the interpreter, as shown below.

Imagem

A Ruby program may write to the ENV object. On most systems this changes the values of the corresponding environment variables. However, this change is local to the process that makes it and to any subsequently spawned child processes. A subprocess changes an environment variable, and this change is inherited by a process that it then starts. However, the change is not visible to the original parent. (This just goes to prove that parents never really know what their children are doing.)


<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
ENV["course"] = "FORPC101"  
puts "#{ENV['course']}"  
<% end %>


h2.Argumentos de linha de comando

If you're starting a program from the command line, you can append parameters onto the end of the command and the program processes them.

You can do the same with your Ruby application. Ruby automatically places any parameters that are appended to the command line when you launch your Ruby program into a special array called ARGV. If your program is:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
f = ARGV[0]  
puts f  
<% end %>

You can execute this program from the command line as:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
ruby tmp.rb 23
<% end %>

The program should display 23.


h2.Biblioteca GetoptLong

Class GetoptLong supports command-line option parsing. Options may be a minus sign (-) followed by a single character, or two minus signs (--) followed by a name (a long option). Options may be given in any order. A single internal option may have multiple external representations. For example, the option to control verbose output could be any of -v, --verbose, or --details. Some options may also take an associated value. Each internal option is passed to GetoptLong as an array, containing strings representing the option's external forms and a flag. The flag specifies how GetoptLong is to associate an argument with the option (NO_ARGUMENT, REQUIRED_ARGUMENT, or OPTIONAL_ARGUMENT).

Suppose I want to call a Ruby program as:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
ruby tsftpc.rb -hftp.ibiblio.org -n21 -uanonymous -ps@s.com
<% end %>

Here's the code to do so:


<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
require 'getoptlong'  
   
# Call using "ruby tsftpc.rb -hftp.ibiblio.org -n21 -uanonymous -ps@s.com"  
# The parameters can be in any order  
unless ARGV.length == 4  
  puts "Usage: ruby tsftpc.rb -hftp_site_url -nport_no -uuser_name -ppassword"  
  exit  
end  
   
host_name = port_no = user_name = password = ''  
# specify the options we accept and initialize  
# the option parser  
opts = GetoptLong.new(  
[ "--hostname", "-h", GetoptLong::REQUIRED_ARGUMENT ],  
[ "--port", "-n", GetoptLong::REQUIRED_ARGUMENT ],  
[ "--username", "-u", GetoptLong::REQUIRED_ARGUMENT ],  
[ "--pass", "-p", GetoptLong::REQUIRED_ARGUMENT ]  
)  
# process the parsed options  
opts.each do |opt, arg|  
  case opt  
    when '--hostname'  
      host_name = arg  
    when '--port'  
      port_no = arg  
    when '--username'  
      user_name = arg  
    when '--pass'  
      password = arg  
  end  
end  
<% end %>

require gives you access to the many extensions and programming libraries bundled with the Ruby programming language-as well as an even larger number of extensions and libraries written independently by other programmers and made available for use with Ruby. We shall be studying require in more detail, later on. Also, later on, we shall study how to access constants using ::

How do I convert objects into an Array? If you want to wrap objects in an Array, you can use a special Kernel module Array method (that starts with a capital letter and looks like a class). This special method converts its argument into an array. For example:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
str = 'hello'  
print Array(str).class # Array  
<% end %>

Another example:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
str = 'hello\nworld'  
print Array(str) # ["hello\\nworld"]  
<% end %>


What are the ancestors of Array? Run the following program, to find that out:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
a = [1,2,3,4]  
print a.class.ancestors  
<% end %>

You should see:

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
[Array, Enumerable, Object, Kernel, BasicObject]  
<% end %>


You can refer to all the details of the Array class here.

